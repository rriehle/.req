#!/usr/bin/env bb

(ns ^:clj-kondo/ignore req-search
  (:require [clojure.java.io :as io]
            [clojure.string :as str]
            [babashka.fs :as fs]))

;; Load shared libraries
(load-file (str (fs/expand-home "~/.req/req-core.bb")))
(def load-config (:load-config req-core/exports))
(def resolve-req-path (:resolve-req-path req-core/exports))
(def read-req-metadata (:read-req-metadata req-core/exports))
(def list-reqs (:list-reqs req-core/exports))

;; ============================================================================
;; Configuration
;; ============================================================================

(defn get-req-dir
  "Get requirements directory from config"
  []
  (let [config-result (load-config)]
    (resolve-req-path config-result)))


;; ============================================================================
;; Search Functions
;; ============================================================================

(defn search-by-tag [tag reqs]
  (let [; Strip leading : if present, then convert to keyword
        tag-str (if (string? tag)
                  (if (str/starts-with? tag ":")
                    (subs tag 1)
                    tag)
                  (str tag))
        tag-kw (keyword tag-str)]
    (filter #(contains? (:tags %) tag-kw) reqs)))

(defn search-by-content [query reqs]
  (filter #(str/includes? (str/lower-case (:content %))
                          (str/lower-case query))
          reqs))

(defn search-by-status [status reqs]
  (let [status-str (if (string? status)
                     (if (str/starts-with? status ":")
                       (subs status 1)
                       status)
                     (str status))]
    (filter #(when-let [s (:status %)]
               (= (str/lower-case (name s))
                  (str/lower-case status-str)))
            reqs)))

(defn search-by-category [category reqs]
  (let [cat-str (if (string? category)
                  (if (str/starts-with? category ":")
                    (subs category 1)
                    category)
                  (str category))
        cat-kw (keyword cat-str)]
    (filter #(= (:category %) cat-kw) reqs)))

(defn search-by-priority [priority reqs]
  (let [pri-str (if (string? priority)
                  (if (str/starts-with? priority ":")
                    (subs priority 1)
                    priority)
                  (str priority))
        pri-kw (keyword pri-str)]
    (filter #(= (:priority %) pri-kw) reqs)))

(defn search-by-type [type reqs]
  (let [type-str (if (string? type)
                   (if (str/starts-with? type ":")
                     (subs type 1)
                     type)
                   (str type))
        type-kw (keyword type-str)]
    (filter #(= (:type %) type-kw) reqs)))

(defn search-by-adr [adr-id reqs]
  "Search requirements that reference a specific ADR"
  (filter #(when-let [adr-refs (get-in % [:trace :adr])]
             (contains? adr-refs adr-id))
          reqs))

(defn search-by-runnote [runnote-name reqs]
  "Search requirements that reference a specific RunNotes file"
  (filter #(when-let [runnote-refs (get-in % [:trace :runnote])]
             (some (fn [ref] (str/includes? ref runnote-name)) runnote-refs))
          reqs))

;; ============================================================================
;; Display Functions
;; ============================================================================

(defn safe-name [v]
  "Safely convert value to name, handling keywords, strings, and other types"
  (cond
    (keyword? v) (name v)
    (string? v) v
    :else (str v)))

(defn print-req [req]
  (println (str "\n" (:req-id req) " - " (:title req)))
  (println (str "  File: " (:file req)))
  (println (str "  Type: " (safe-name (:type req))))
  (println (str "  Category: " (safe-name (:category req))))
  (println (str "  Priority: " (safe-name (:priority req))))
  (println (str "  Status: " (safe-name (:status req))))
  (when (seq (:tags req))
    (println (str "  Tags: " (str/join " " (map #(str ":" (safe-name %)) (:tags req))))))
  (when-let [trace (:trace req)]
    (when (seq (:adr trace))
      (println (str "  ADRs: " (str/join ", " (:adr trace)))))
    (when (seq (:code trace))
      (println (str "  Code: " (str/join ", " (:code trace)))))
    (when (seq (:tests trace))
      (println (str "  Tests: " (str/join ", " (:tests trace)))))))

(defn list-all-tags
  "List all unique tags used across requirements"
  []
  (let [req-dir (get-req-dir)
        reqs (list-reqs req-dir)
        all-tags (mapcat :tags reqs)]
    (sort (distinct all-tags))))

(defn list-all-categories
  "List all unique categories used across requirements"
  []
  (let [req-dir (get-req-dir)
        reqs (list-reqs req-dir)]
    (sort (distinct (map :category reqs)))))

(defn print-tag-summary
  "Print a summary of tag usage across requirements"
  []
  (let [reqs (list-reqs)
        all-tags (mapcat :tags reqs)
        tag-freq (frequencies all-tags)
        sorted-tags (sort-by val > tag-freq)]
    (println "\nTag Usage Summary:")
    (println "==================")
    (doseq [[tag count] sorted-tags]
      (println (format "  %-30s %d requirement%s"
                       (str ":" (name tag))
                       count
                       (if (= count 1) "" "s"))))))

(defn print-summary
  "Print summary statistics about requirements"
  []
  (let [req-dir (get-req-dir)
        reqs (list-reqs req-dir)
        total (count reqs)
        by-type (group-by :type reqs)
        by-priority (group-by :priority reqs)
        by-status (group-by :status reqs)
        by-category (group-by :category reqs)]
    (println "\nðŸ“Š Requirements Summary")
    (println "======================")
    (println (str "\nTotal Requirements: " total))

    (println "\nBy Type:")
    (doseq [[type group] (sort by-type)]
      (println (format "  %-20s %d" (safe-name type) (count group))))

    (println "\nBy Priority:")
    (doseq [[pri group] (sort by-priority)]
      (println (format "  %-20s %d" (safe-name pri) (count group))))

    (println "\nBy Status:")
    (doseq [[status group] (sort by-status)]
      (println (format "  %-20s %d" (safe-name status) (count group))))

    (println "\nBy Category:")
    (if (seq by-category)
      (do
        ; Debug: print raw structure
        ; (println "DEBUG by-category:" (pr-str by-category))
        (doseq [[cat group] by-category]  ; Don't sort, just iterate
          (println (format "  %-20s %d" (safe-name cat) (count group)))))
      (println "  No categories found"))))

;; ============================================================================
;; Usage
;; ============================================================================

(defn print-usage []
  (println "Usage: req-search [command] [args]")
  (println "")
  (println "Commands:")
  (println "  list                       - List all requirements")
  (println "  tag <keyword>             - Search by tag (e.g., :authentication)")
  (println "  content <query>           - Search by content")
  (println "  status <status>           - Search by status (e.g., accepted)")
  (println "  category <category>       - Search by category (e.g., :security)")
  (println "  priority <priority>       - Search by priority (e.g., :must)")
  (println "  type <type>               - Search by type (functional or non-functional)")
  (println "  adr <adr-id>              - Find requirements linked to an ADR")
  (println "  runnote <name>            - Find requirements linked to a RunNotes file")
  (println "  list-tags                 - List all unique tags")
  (println "  list-categories           - List all unique categories")
  (println "  tag-summary               - Show tag usage statistics")
  (println "  summary                   - Show requirements summary statistics")
  (println "  help                      - Show this help"))

;; ============================================================================
;; Main
;; ============================================================================

(defn -main [& args]
  (let [command (first args)
        req-dir (get-req-dir)
        reqs (list-reqs req-dir)]
    (case command
      "list" (doseq [req reqs]
               (print-req req))

      "tag" (if-let [tag (second args)]
              (let [results (search-by-tag tag reqs)]
                (if (seq results)
                  (doseq [req results]
                    (print-req req))
                  (println "No requirements found with tag:" tag)))
              (println "Please specify a tag"))

      "content" (if-let [query (second args)]
                  (let [results (search-by-content query reqs)]
                    (if (seq results)
                      (doseq [req results]
                        (print-req req))
                      (println "No requirements found containing:" query)))
                  (println "Please specify a search query"))

      "status" (if-let [status (second args)]
                 (let [results (search-by-status status reqs)]
                   (if (seq results)
                     (doseq [req results]
                       (print-req req))
                     (println "No requirements found with status:" status)))
                 (println "Please specify a status"))

      "category" (if-let [category (second args)]
                   (let [results (search-by-category category reqs)]
                     (if (seq results)
                       (doseq [req results]
                         (print-req req))
                       (println "No requirements found with category:" category)))
                   (println "Please specify a category"))

      "priority" (if-let [priority (second args)]
                   (let [results (search-by-priority priority reqs)]
                     (if (seq results)
                       (doseq [req results]
                         (print-req req))
                       (println "No requirements found with priority:" priority)))
                   (println "Please specify a priority"))

      "type" (if-let [type (second args)]
               (let [results (search-by-type type reqs)]
                 (if (seq results)
                   (doseq [req results]
                     (print-req req))
                   (println "No requirements found with type:" type)))
               (println "Please specify a type (functional or non-functional)"))

      "adr" (if-let [adr-id (second args)]
              (let [results (search-by-adr adr-id reqs)]
                (if (seq results)
                  (doseq [req results]
                    (print-req req))
                  (println "No requirements found linked to ADR:" adr-id)))
              (println "Please specify an ADR ID"))

      "runnote" (if-let [runnote (second args)]
                  (let [results (search-by-runnote runnote reqs)]
                    (if (seq results)
                      (doseq [req results]
                        (print-req req))
                      (println "No requirements found linked to RunNotes:" runnote)))
                  (println "Please specify a RunNotes filename"))

      "list-tags" (let [tags (list-all-tags)]
                    (if (seq tags)
                      (do (println "\nAll tags used in requirements:")
                          (doseq [tag tags]
                            (println (str "  :" (name tag)))))
                      (println "No tags found in requirements")))

      "list-categories" (let [categories (list-all-categories)]
                          (if (seq categories)
                            (do (println "\nAll categories used in requirements:")
                                (doseq [cat categories]
                                  (println (str "  :" (name cat)))))
                            (println "No categories found in requirements")))

      "tag-summary" (print-tag-summary)

      "summary" (print-summary)

      "help" (print-usage)

      (do
        (println "Unknown command:" command)
        (print-usage)))))

;; ============================================================================
;; CLI entry point
;; ============================================================================

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
